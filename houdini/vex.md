### Предисловие

Данная статья предназначена для тех, кто уже имеет некоторое интуитивное представление о
[VEX](#https://www.sidefx.com/docs/houdini/vex/index.html), для тех, кто уже видел
[Wrangle](#https://www.sidefx.com/docs/houdini/nodes/sop/attribwrangle) в сетапах или повторял туторы.

Цель статьи - формализовать интуитивное представление, объяснить базовые концепции VEX, преобладающие в контексте
геометрических и вольюм вранглов, и собственно базовые концепции самих вранглов. В статье иногда приводятся примеры в
виде hpaste-ссылок, типа `ofelarenor@HPaste` эти ссылки содержат куски нодового графа, которые можно одним нажатием
хоткея вставить в свою гудини сцену. Подробнее читайте в [репозитории](#https://github.com/pedohorse/hpaste) плагина.


-------
### VEX

VEX - это простой по дизайну и очень высокопроизводительный язык, используемый в Houdini для обработки геометрии и
шейдинга. VEX - язык спроектированный для выполнения одного и того же кода на большом массиве входных данных. Этими
данными могут быть пиксели картинки, шейдинг семплы, воксели вольюма, точки/вертексы/примитивы/и т.п геометрии. VEX -
язык процедурной парадигмы с небольшим влиянием некоторых базовых концепций ООП, синтаксисом похож на упрощённый
javascript, или очень упрощённый C. Сразу замечу, что учить C ради изучения VEX - пустая трата времени, так как эти
языки очень разные, и VEX - значительно проще и более ограниченный чем С.

Язык VEX компилируемый, это значит, что перед выполнением VEX программы её проанализирует некоторая другая программа,
называемая компилятором, которая на выходе выдаст преобразованную VEX программу в некоторое эффективное для выполнения
представление. Это представление может и не являться машинным кодом, но в данной статье это не важно.


#### Базовые концепции

##### Инструкции

Код программы состоит из инструкций (`statement`), которые выполняются последовательно. Некоторые инструкции влияют на
дальнейший порядок выполнения:

```c
x = 1;
y = 2 + 3 * 4; // простые инструкции
while(1) {}
if(x == 1) y = 2; // составные инструкции
{x = 1; y = 2;} // блок инструкция
```


##### Выражения

Выражения (`expression`) - это составные части инструкций, имеющие некоторый результат:

```c
2 + 3;
2 >= 5; // это выражение
x = 7; // в VEX это тоже является выражением, его результат - 7, а побочный эффект - присвоения переменной х этого же значения 7
if(x = 5) {}
// Эту путающую особенность VEX взял скорее всего из C, зачем - непонятно, во многих современных языках, даже в том же
// Python, оператор присваивания не является частью выражения, что позволяет избежать глупых ошибок типа скорее всего автор
// этой строки хотел проверить, равен ли `х` пяти и сделать что-то в этом случае, но оператор проверки равенства в VEX -
// двойное равно `==`. Так что строка выше на самом деле присваивает переменной `x` значение 5 и вернет 5, от чего условие
// `if` выполнится. Ясное дело, что это мелкое недоразумение полностью ломает программу.
```


##### Переменные

Переменные (`variables`) в VEX - это области памяти, где хранится некоторое значение, некоторого типа. Переменные надо
объявлять заранее с заданным типом, который не может быть изменён по ходу выполнения программы.

```c
int x;
x = 42;
float f = 3.14156;

int y = 42;
string y = "hello, VEX!"; // Ошибка компиляции: Недопустимое присваивание значения типа string типу int и Множественные объявления переменной: x
```


##### Литералы

Литералы - это константные значения, являющиеся собственно частью кода программы.
`1 3 1942 2.3445 1e-4 "qwerty" {1.2,4,-1}` - это всё литералы. Литералы участвуют в выражениях и инструкциях, и в целом
везде. Вы можете думать о них как о значениях, создаваемых компилятором VEX в момент компиляции кода, а не на момент его
выполнения, а поэтому никаких переменных и прочих выражений в литералах не может быть.

Так, что записи вида:

```c
float a = 1;
vector v = {a, 2, 3}; // являются ошибкой, тогда как
vector v = {42, 2, 3}; // корректная инструкция
```


##### Логический тип

Логического типа в VEX нет, так что все логические выражения, типа `1 > 2`, `a == b`, `!c` возвращают значение типа
`int`, 1 - в случае истины (`true`), 0 - в случае лжи (`false`). В целом же любое ненулевое значение `int` считается
истиной (`true`)


##### Ленивая логика

В VEX, как и в очень многих языках, не только си-подобных, существует концепция ленивых логических вычислений. Суть
концепции в том, что если результат логического оператора понятен после вычисления только первого из операндов - то
второй операнд вычисляться и не будет. В VEX два бинарных логических оператора: `&&` (И) и `||` (ИЛИ) суть их проста:
- `a && b` возвращает 1, если оба `a` и `b` не равны нулю, иначе - 0
- `a || b` возвращает 1, если хотя бы один из `a` или `b` не равен нулю, иначе - 0

Отсюда видно, что, в случае:
- `a && b`, если `a` был вычислен и результат равен нулю, то значение `b` уже совершенно не важно, оба `a` и `b` никогда не будут ненулевыми, так что выражение `b` вообще не вычисляется.
- `a || b`, если `a` был вычислен и результат не равен нулю, то значение выражения `b` уже не важно, результат всего оператора `||` уже будет 1

На примере выражений без вызова функций не очень понятно, как важна эта концепция, в случае наличия вызовов функций в
невычисляемом выражении `b`, естественно эти функции не будут вызваны:

```c
int print_and_ret(int val){
  printf("val = %d\n", val);
  return val;
}
int y = print_and_ret(10) || print_and_ret(0); // значением y будет 1, а в консоль выведется только val = 10, функция print_and_ret(0) вызвана не будет
```

Замечание: привыкшим к ленивой логике в Python - в VEX "питоновских" трюков не выйдет, логические операторы всегда
возвращают `int`, и именно 1 в случае истины, и 0 в случае лжи.


##### Инструкции управление потоком выполнения

В VEX существует более-менее ожидаемый набор для управления тем, какие инструкции будут выполняться дальше. В дальнейшем
описании `<expression>` будет означать некоторое выражение, `<statement>` - некоторую инструкцию.


###### if else

`if(expression) <statement>;`

В случае результата `<expression>` не равного нулю будет выполнена инструкция `<statement>` так как в VEX присутствует
блок-инструкция `{}`, вместо одной инструкции мы можем выполнить много,

`if(<expression>){<statement1>; <statement2>; .......; <statementN>}`

В VEX, в отличии от Python, переносы строки, пробелы и форматирование в целом не являются частью синтаксиса, поэтому
можно хоть всю программу записать в одну единую длинную строку. Но удобная и более читаемая форма всё таки использовать
переносы строк и отступы для блоков, хоть это и не обязательно, например

```
if(<expression>){
    <statement1>;
    <statement2>;
    .......
    <statementN>
}
```

Расширенная версия этой инструкции:

`if(<expression>) <statement1>; else <statement2>;`

Если результат `<expression>` не равен нулю - будет выполнена инструкция `<statement1>`, иначе же - `<statement2>`

```c
int a = 2;
if(a > 1) a++; else a *= 10;
// a инициализируется значением 2, затем вычисляется выражение a > 1, что есть истина,
// а значит результатом будет 1, что не равно нулю, а значит выполнится а++
printf("a = %d\n", a);
```


###### while

`while(<expression>) <statement>;`

До тех пор, пока выражение `<expression>` не равно нулю, будет выполнена инструкция `<statement>`. Например,

```c
while(x < 10) ++x;
```
Заметьте, `<expression>` вычисляется и проверяется каждый раз перед решением, выполнять ли `<statement>` или нет.

Другая форма цикла `while`,

`do <statement>; while(<expression>)`

Логика тут ровно такая же, как у обычного `while`, за исключением того, что `<statement>` выполнится один дополнительный
раз в самом начале, до проверки условия `<expression>`.


###### for

`for(<expr_init>; <expr_cond>; <expr_inc>) <statement>;`

Логика этой инструкции следующая:
1. выполнить выражение `<expr_init>` (результат не важен). В данном случае вместо обычного выражение может быть
   использовано объявление переменной. В таком случае область видимости объявленных переменных ограничено областью
видимости `<statement>`
2. вычислить `<expr_cond>`, если оно неравно нулю, то выполнить `<statement>`, иначе - закончить вычисление данной
   инструкции, перейти к следующей
3. вычислить выражение `<expr_inc>`, результат отбросить, и вернуться к пункту 2.

Классический пример цикла `for`:

```c
for(int i = 0; i < 10; i++) printf("iter %d\n", i);
```

Шаги выполнения следующие:
1. объявить переменную `i` равную нулю
2. проверить, `i < 10`, если нет - всё, цикл окончен, если да - то выполняем `<statement>` `printf("iter %d\n", i}`;
3. выполняем `i++`, возвращаемся к 2 пустое выражение/инструкция - тоже вполне допустимы

```c
int i = 0;
for(; i < 10; ) printf("iter %d\n",i); i++;
```

и даже

```c
for(;;) printf("run forever\n");
```

Всё это вполне легальные инструкции.


##### foreach

Цикл `foreach` имеет несколько форм в VEX:

`foreach(<variable>; <array_expression>) <statement>;`

и

`foreach(<int_variable>; <variable>; <array_expression>) <statement>;`

В этих циклах вычисляется выражение `<array_expression>`, результатом которого должен быть массив некоторого типа,
являющегося типом переменной `<variable>` далее переменной `<variable>` будет присваиваться каждый элемент полученного
массива по очереди и исполняться `<statement>` в случае версии `foreach` с `<int_variable>` - так же переменной
`<int_variable>` будет присвоен номер текущего элемента массива.

То есть следующие конструкции делают одно и то же:

```c
int numbers[] = {2, 9, 3, -6, 9, 1, 0, 3, 0, -5};

foreach(int i; int n; numbers){
  printf("iter %d, number %d\n", i, n);
}

for(int i = 0; i < len(numbers); i++){
  int n = numbers[i];
  printf("iter %d, number %d\n", i, n);
}
```

###### break/continue

Ключевые слова `break` и `continue` могут использоваться внутри любого из описанных выше циклов: `while`, `do..while`,
`for`, `foreach`.

Инструкция `break` внутри блок-инструкции цикла - немедленно прекращает выполнение цикла и переходит к следующей
инструкции после цикла инструкция `continue` внутри блок-инструкции цикла немедленно заканчивает выполнение текущей
итерации цикла и переходит к следующей, соблюдая все правила цикла, в котором она находится.

Например,

```c
for(int i = 0; i < 100; ++i){
  printf("iteration %d\n);
  if(i == 25) break;
  printf("going\n");
}
printf("for finished");
```

Совершит 25 итераций, выдаст по 2 строки на каждую итерацию, затем на 26-ой итерации выдаст `iteration` 25 и выйдет из
цикла к следующей инструкции `printf`, и выдаст в консоль: `for finished`

Другой пример,

```c
for(int i = 99; i >= 0; i--){
  if(i % 2 != 0) continue;
  printf("%d is even\n", i);
}
```

В этом примере `i % 2` возвращает остаток от целочисленного деления `i` на 2, который мы проверяем на неравенство нулю.
Если остаток от деления на 2 не равен нулю - инструкция `continue` выполняется и блок-инструкция цикла немедленно
заканчивается, и цикл переходит к следующей итерации.

В выводе вы увидите `98 is even  96 is even  94 is even ....` и прочие чётные числа до нуля включительно вне циклов
использовать инструкции `break` и `continue` - ошибка.


###### return

Инструкция `return <expression>` используется внутри тела определяемой функции, чтобы немедленно закончить выполнение
функции и вернуть результат вычисления выражения `<expression>` как результат.
Так же в теле вранглов инструкция `return` без выражения используется для немедленного прекращения вычисления врангла
для текущего элемента.
