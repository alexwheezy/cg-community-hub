### Предисловие

Данная статья предназначена для тех, кто уже имеет некоторое интуитивное представление о
[VEX](https://www.sidefx.com/docs/houdini/vex/index.html), для тех, кто уже видел
[Wrangle](https://www.sidefx.com/docs/houdini/nodes/sop/attribwrangle) в сетапах или повторял туторы.

Цель статьи - формализовать интуитивное представление, объяснить базовые концепции VEX, преобладающие в контексте
геометрических и вольюм вранглов, и собственно базовые концепции самих вранглов. В статье иногда приводятся примеры в
виде hpaste-ссылок, типа `ofelarenor@HPaste` эти ссылки содержат куски нодового графа, которые можно одним нажатием
хоткея вставить в свою гудини сцену. Подробнее читайте в [репозитории](https://github.com/pedohorse/hpaste) плагина.


-------
### VEX

VEX - это простой по дизайну и очень высокопроизводительный язык, используемый в Houdini для обработки геометрии и
шейдинга. VEX - язык спроектированный для выполнения одного и того же кода на большом массиве входных данных. Этими
данными могут быть пиксели картинки, шейдинг семплы, воксели вольюма, точки/вертексы/примитивы/и т.п геометрии. VEX -
язык процедурной парадигмы с небольшим влиянием некоторых базовых концепций ООП, синтаксисом похож на упрощённый
javascript, или очень упрощённый C. Сразу замечу, что учить C ради изучения VEX - пустая трата времени, так как эти
языки очень разные, и VEX - значительно проще и более ограниченный чем С.

Язык VEX компилируемый, это значит, что перед выполнением VEX программы её проанализирует некоторая другая программа,
называемая компилятором, которая на выходе выдаст преобразованную VEX программу в некоторое эффективное для выполнения
представление. Это представление может и не являться машинным кодом, но в данной статье это не важно.


#### Базовые концепции

##### Инструкции

Код программы состоит из инструкций (`statement`), которые выполняются последовательно. Некоторые инструкции влияют на
дальнейший порядок выполнения:

```c
x = 1;
y = 2 + 3 * 4; // простые инструкции
while(1) {}
if(x == 1) y = 2; // составные инструкции
{x = 1; y = 2;} // блок инструкция
```


##### Выражения

Выражения (`expression`) - это составные части инструкций, имеющие некоторый результат:

```c
2 + 3;
2 >= 5; // это выражение

// в VEX это тоже является выражением, его результат - 7,
// а побочный эффект - присвоения переменной х этого же значения 7
x = 7;

if(x = 5) {}
```

Эту путающую особенность VEX взял скорее всего из C, зачем - непонятно, во многих современных языках, даже в том же
Python, оператор присваивания не является частью выражения, что позволяет избежать глупых ошибок типа скорее всего автор
этой строки хотел проверить, равен ли `х` пяти и сделать что-то в этом случае, но оператор проверки равенства в VEX -
двойное равно `==`. Так что строка выше на самом деле присваивает переменной `x` значение 5 и вернет 5, от чего условие
`if` выполнится. Ясное дело, что это мелкое недоразумение полностью ломает программу.


##### Переменные

Переменные (`variables`) в VEX - это области памяти, где хранится некоторое значение, некоторого типа. Переменные надо
объявлять заранее с заданным типом, который не может быть изменён по ходу выполнения программы.

```c
int x;
x = 42;
float f = 3.14156;

int y = 42;
string y = "hello, VEX!"; // Ошибка компиляции
// Недопустимо присваивать значения типа string типу int,
// a так же множественные объявления переменной: y
```


##### Литералы

Литералы - это константные значения, являющиеся собственно частью кода программы.
`1 3 1942 2.3445 1e-4 "qwerty" {1.2,4,-1}` - это всё литералы. Литералы участвуют в выражениях и инструкциях, и в целом
везде. Вы можете думать о них как о значениях, создаваемых компилятором VEX в момент компиляции кода, а не на момент его
выполнения, а поэтому никаких переменных и прочих выражений в литералах не может быть.

Так, что записи вида:

```c
float a = 1;
vector v = {a, 2, 3}; // являются ошибкой, тогда как
vector v = {42, 2, 3}; // корректная инструкция
```


##### Логический тип

Логического типа в VEX нет, так что все логические выражения, типа `1 > 2`, `a == b`, `!c` возвращают значение типа
`int`, 1 - в случае истины (`true`), 0 - в случае лжи (`false`). В целом же любое ненулевое значение `int` считается
истиной (`true`)


##### Ленивая логика

В VEX, как и в очень многих языках, не только си-подобных, существует концепция ленивых логических вычислений. Суть
концепции в том, что если результат логического оператора понятен после вычисления только первого из операндов - то
второй операнд вычисляться и не будет. В VEX два бинарных логических оператора: `&&` (И) и `||` (ИЛИ) суть их проста:
- `a && b` возвращает 1, если оба `a` и `b` не равны нулю, иначе - 0
- `a || b` возвращает 1, если хотя бы один из `a` или `b` не равен нулю, иначе - 0

Отсюда видно, что, в случае:
- `a && b`, если `a` был вычислен и результат равен нулю, то значение `b` уже совершенно не важно, оба `a` и `b` никогда
не будут ненулевыми, так что выражение `b` вообще не вычисляется.
- `a || b`, если `a` был вычислен и результат не равен нулю, то значение выражения `b` уже не важно, результат всего
оператора `||` уже будет 1

На примере выражений без вызова функций не очень понятно, как важна эта концепция, в случае наличия вызовов функций в
невычисляемом выражении `b`, естественно эти функции не будут вызваны:

```c
int print_and_ret(int val){
  printf("val = %d\n", val);
  return val;
}
int y = print_and_ret(10) || print_and_ret(0);
// значением y будет 1, а в консоль выведется только val = 10,
// функция print_and_ret(0) вызвана не будет
```

Замечание: привыкшим к ленивой логике в Python - в VEX "питоновских" трюков не выйдет, логические операторы всегда
возвращают `int`, и именно 1 в случае истины, и 0 в случае лжи.


##### Инструкции управление потоком выполнения

В VEX существует более-менее ожидаемый набор для управления тем, какие инструкции будут выполняться дальше. В дальнейшем
описании `<expression>` будет означать некоторое выражение, `<statement>` - некоторую инструкцию.


###### if else

`if(expression) <statement>;`

В случае результата `<expression>` не равного нулю будет выполнена инструкция `<statement>` так как в VEX присутствует
блок-инструкция `{}`, вместо одной инструкции мы можем выполнить много,

`if(<expression>){<statement1>; <statement2>; .......; <statementN>}`

В VEX, в отличии от Python, переносы строки, пробелы и форматирование в целом не являются частью синтаксиса, поэтому
можно хоть всю программу записать в одну единую длинную строку. Но удобная и более читаемая форма всё таки использовать
переносы строк и отступы для блоков, хоть это и не обязательно, например

```
if(<expression>){
    <statement1>;
    <statement2>;
    .......
    <statementN>
}
```

Расширенная версия этой инструкции:

`if(<expression>) <statement1>; else <statement2>;`

Если результат `<expression>` не равен нулю - будет выполнена инструкция `<statement1>`, иначе же - `<statement2>`

```c
int a = 2;
if(a > 1) a++; else a *= 10;
// a инициализируется значением 2, затем вычисляется выражение a > 1, что есть истина,
// а значит результатом будет 1, что не равно нулю, а значит выполнится а++
printf("a = %d\n", a);
```


###### while

`while(<expression>) <statement>;`

До тех пор, пока выражение `<expression>` не равно нулю, будет выполнена инструкция `<statement>`. Например,

```c
while(x < 10) ++x;
```
Заметьте, `<expression>` вычисляется и проверяется каждый раз перед решением, выполнять ли `<statement>` или нет.

Другая форма цикла `while`,

`do <statement>; while(<expression>)`

Логика тут ровно такая же, как у обычного `while`, за исключением того, что `<statement>` выполнится один дополнительный
раз в самом начале, до проверки условия `<expression>`.


###### for

`for(<expr_init>; <expr_cond>; <expr_inc>) <statement>;`

Логика этой инструкции следующая:
1. выполнить выражение `<expr_init>` (результат не важен). В данном случае вместо обычного выражение может быть
   использовано объявление переменной. В таком случае область видимости объявленных переменных ограничено областью
видимости `<statement>`
2. вычислить `<expr_cond>`, если оно неравно нулю, то выполнить `<statement>`, иначе - закончить вычисление данной
   инструкции, перейти к следующей
3. вычислить выражение `<expr_inc>`, результат отбросить, и вернуться к пункту 2.

Классический пример цикла `for`:

```c
for(int i = 0; i < 10; i++) printf("iter %d\n", i);
```

Шаги выполнения следующие:
1. объявить переменную `i` равную нулю
2. проверить, `i < 10`, если нет - всё, цикл окончен, если да - то выполняем `<statement>` `printf("iter %d\n", i}`;
3. выполняем `i++`, возвращаемся к 2 пустое выражение/инструкция - тоже вполне допустимы

```c
int i = 0;
for(; i < 10; ) printf("iter %d\n",i); i++;
```

и даже

```c
for(;;) printf("run forever\n");
```

Всё это вполне легальные инструкции.


###### foreach

Цикл `foreach` имеет несколько форм в VEX:

`foreach(<variable>; <array_expression>) <statement>;`

и

`foreach(<int_variable>; <variable>; <array_expression>) <statement>;`

В этих циклах вычисляется выражение `<array_expression>`, результатом которого должен быть массив некоторого типа,
являющегося типом переменной `<variable>` далее переменной `<variable>` будет присваиваться каждый элемент полученного
массива по очереди и исполняться `<statement>` в случае версии `foreach` с `<int_variable>` - так же переменной
`<int_variable>` будет присвоен номер текущего элемента массива.

То есть следующие конструкции делают одно и то же:

```c
int numbers[] = {2, 9, 3, -6, 9, 1, 0, 3, 0, -5};

foreach(int i; int n; numbers){
  printf("iter %d, number %d\n", i, n);
}

for(int i = 0; i < len(numbers); i++){
  int n = numbers[i];
  printf("iter %d, number %d\n", i, n);
}
```

###### break/continue

Ключевые слова `break` и `continue` могут использоваться внутри любого из описанных выше циклов: `while`, `do..while`,
`for`, `foreach`.

Инструкция `break` внутри блок-инструкции цикла - немедленно прекращает выполнение цикла и переходит к следующей
инструкции после цикла инструкция `continue` внутри блок-инструкции цикла немедленно заканчивает выполнение текущей
итерации цикла и переходит к следующей, соблюдая все правила цикла, в котором она находится.

Например,

```c
for(int i = 0; i < 100; ++i){
  printf("iteration %d\n);
  if(i == 25) break;
  printf("going\n");
}
printf("for finished");
```

Совершит 25 итераций, выдаст по 2 строки на каждую итерацию, затем на 26-ой итерации выдаст `iteration` 25 и выйдет из
цикла к следующей инструкции `printf`, и выдаст в консоль: `for finished`

Другой пример,

```c
for(int i = 99; i >= 0; i--){
  if(i % 2 != 0) continue;
  printf("%d is even\n", i);
}
```

В этом примере `i % 2` возвращает остаток от целочисленного деления `i` на 2, который мы проверяем на неравенство нулю.
Если остаток от деления на 2 не равен нулю - инструкция `continue` выполняется и блок-инструкция цикла немедленно
заканчивается, и цикл переходит к следующей итерации.

В выводе вы увидите `98 is even  96 is even  94 is even ....` и прочие чётные числа до нуля включительно вне циклов
использовать инструкции `break` и `continue` - ошибка.


###### return

Инструкция `return <expression>` используется внутри тела определяемой функции, чтобы немедленно закончить выполнение
функции и вернуть результат вычисления выражения `<expression>` как результат. Так же в теле вранглов инструкция
`return` без выражения используется для немедленного прекращения вычисления врангла для текущего элемента.


##### Операторы , ;

Литерал точка с запятой `;` используется в VEX для разделения инструкций.

```c
a = b * 2 + 12; c = 1 + 2; float d = foo(a);
```

Как мы уже знаем, пробелы, табы и переносы строк не являются разделителями инструкций, так что это:

```c
a = b * 2;
```

Так же верно, как и это:

```c
a
=
b
*
2
;
```

Исключением тут являются блок-стейтменты, границы которого заранее чётко определены, так что точка с запятой после него
не требуется.

Литерал запятая `,` - это оператор, такой же как `+` - `*` и т.п. `<expression1>, <expression2>` этот оператор вычисляет
выражение `<expression1>`, затем вычисляет выражение `<expression2>` результат вычисления `<expression2>` становится
результатом оператора.

Например:

```c
a = (4 + 9, 2); // значением в a будет 2
```

Одна из классических ошибок, особенно для тех, кто привык к инициализации `vector` из OpenCL, это писать следующее:
```c
vector vec = (vector)(1, 2, 3);  // неожиданный результат
```

или

```c
vector vec = (1, 2, 3);  // неожиданный результат
```

В обоих случаях компилятор не выдаст даже предупреждения, но что на самом деле произойдет:
- в VEX нет инициализации `vector` как в OpenCL - `(vector)(1, 2, 3)`
- выражение `(1, 2, 3)` будет посчитано как: `((1, 2), 3), 1, 2 = 2` и `2, 3 = 3`, результат равен `3`
- `(vector)3` - это явное преобразование значения `3` к типу `vector` (подробнее о преобразованиях типов будет дальше)
   результат - `vector {3, 3, 3}`, именно такое значение будет задано переменной `vec` даже без явного преобразования
VEX неявно преобразует результат `3` к типу `vector`, так что результат будет одинаковым для обеих форм записи выше.


##### Приоритет операторов

Важно помнить, что операторы в VEX, как и в большинстве других языков, имеют строго определённый приоритет. Подробную
таблицу приоритета смотрите в [документации](https://www.sidefx.com/docs/houdini/vex/lang.html#precedence).

Парсинг любого выражения происходит с учётом этих приоритетов.

Например,

```c
a = 1 + 2 + 3;
```

Три оператора: два `+` и `=`, смотрим по таблице: у оператора `+` приоритет 15, `у = - 2`, смотрим порядок - `LtR (left
to right)`, слева на право, значит первым исполнится `1 + 2`, затем к результату прибавится `3`, затем отработает
оператор `=`, в итоге:

```
1 + 2 -> 3
3 + 3 -> 6
a = 6
```


###### Тернарный оператор условия

Оператор `<expr1> ? <expr2> : <expr3>` несколько особый в плане приоритета.
Напомню, что действует он так:
1. вычисляется выражение `<expr1>`
2. если результат неравен нулю, то результатом оператора является результат вычисления `<expr2>`
3. иначе, результатом оператора является результат вычисления `<expr3>`

Т.е из `<expr2>` и `<expr3>` будет вычислено только одно из выражений в связи со структурой оператора, приоритет
операторов между `?` и `:` не важен, всё это будет как бы сгруппировано в скобки. В целом проще думать о тернарном
операторе, расставив скобки следующим образом:
- сгруппировать все операторы с приоритетом выше, чем у `?`: слева от `?`
- сгруппировать все операторы с приоритетом выше, чем у `?`: справа от `:`
- всё между `?` и `:` взять в скобки

Например,

```c
x = 1 + 0 ? 2 * 8 : 8 - 18;
```

Слева только у оператора `=` приоритет меньше

```c
x = (1 + 0) ? 2 * 8 : 8 - 18;
```

Справа всё попадает в скобки

```c
x = (1 + 0) ? 2 * 8 : (8 - 18);
```

Ну и всё между `?` и `:`

```c
x = (1 + 0) ? (2 * 8) : (8 - 18);
```

Итого: `1 + 0` не равен нулю, так что будет вычислено `2*8`, результат `16` будет записан в `x` для вложенных тернарных
операторов логика та же, начиная с самого внешнего оператора. Искать соответствие между `?` и `:` можно по той же
логике, что и между открывающей и закрывающей скобкой,

```c
x = 1 + 0 ? 2 - 2 ? 3 * 9 : 2 * 8 : 2 + 2 ? 19 + 2 : 8 - 18;
x = (1 + 0) ? (2 - 2 ? 3 * 9 : 2 * 8) : (2 + 2 ? 19 + 2 : 8 - 18);
x = (1 + 0) ? ((2 - 2) ? (3 * 9) : (2 * 8)) : ((2 + 2) ? (19 + 2) : (8 - 18));
```

В итоге посчитается `1 + 0`, не равен нулю, значит будет вычислено `((2 - 2) ? (3 * 9) : (2 * 8))`
`2 - 2` равно нулю, значит результатом будет `2 * 8`, и опять `16` будет записано в `x`

Теперь более сложный пример, с учётом приоритетов прочих операторов,

```c
int a = 1, b = 2, c = 3;
a += b += c += 2 * 4 ? a * 2 < b ? b + 3 :(3 & b * c) : a;
printf("a = %d, b = %d, c = %d\n", a, b, c);
```

уже `float`, сначала разберемся с тернарными условными операторами,

```c
a += b += c += (2 * 4) ? (a * 2 < b ? b + 3 :(3 & b * c)) : (a);
a += b += c += (2 * 4) ? ((a * 2 < b) ? (b + 3) : (3 & b * c)) : (a);
```

итак, сначала вычисляется условие условного оператора,

```c
a += b += c += (2 * 4) ? ((a * 2 < b) ? (b + 3) : (3 & b * c)) : (a);
a += b += c += 8 ? ((a * 2 < b) ? (b + 3) : (3 & b * c)) : (a);
```

`8` не равно нулю, так что результатом самого внешнего тернарного оператора будет результат вычисления первого из его
выражения

```c
a += b += c += (a * 2 < b) ? (b + 3) : (3 & b * с);
```
это опять тернарный оператор, вычисляем его условие,

```c
a += b += c+= (a * 2 < b) ? (b + 3) : (3 & b * с);
```

по таблице приоритетов сначала выполняется умножение,

```c
a += b += c += (a * 2 < b) ? (b + 3) : (3 & b * c);  // a = 1, b = 2, c = 3
a += b += c += (2 < b) ? (b + 3) : (3 & b * c);
```

далее `<`,

```c
a + =b += c += (2 < b) ? (b + 3) : (3 & b * c);  // a = 1, b = 2, c = 3
a += b += c += (0) ? (b + 3) : (3 & b * c);
```

ноль равен нулю, так что у тернарного условного оператора вычисляем и возвращаем результат последнего выражения

```c
a += b += c += 3 && b * с;
```

приоритет умножения выше, так что

```c
a += b += c += 3 & b * c;  // a = 1, b = 2, c = 3
a += b += c += 3 & 6;
```

теперь побитовое И

```c
a += b += c += 3 & 6; // 3 & 6 -> 11 & 110 = 10 = 2
a += b += c += 2;
```

теперь операторы `+=` выполняются `RtL` - справа на налево

```c
a += b += c += 2;  // a = 1, b = 2, c = 3
a += b += 5;       // a = 1, b = 2, c = 5
a += b += 5;       // a = 1, b = 2, c = 5
a += 7;            // a = 1, b = 7, c = 5
a += 7;            // a = 1, b = 7, c = 5
8;                 // a = 8, b = 7, c = 5
```

в итоге `a = 8`, `b = 7`, `c = 5`.


#### Типизация

В VEX существует набор встроенных типов данных: `string, int, float, vector2, vector3, vector4, matrix2, matrix3,
matrix` и массивы из них и прочих типов, (плюс набор типов данных для шейдинга, который мы пока пропустим). Набор типов
данных может быть расширен как с помощью [HDK](https://www.sidefx.com/docs/hdk/), так и определением новых структур в
VEX коде.


##### Преобразование типов

Как уже говорилось, VEX - язык явной слабой статической типизации:
- "явной" - значит тип каждой переменной должен быть явно задан в программе, как, например, `vector v;`
- "статической" - значит тип переменной определяется один раз на момент компиляции и он не может быть изменён в ходе
работы программы.

В теории языков программирования типизацию характеризуют как слабую/сильную, в зависимости от того, насколько компилятор
фривольно может неявно преобразовывать типы в случае необходимости. Преобразование типа переменной на английском
называется `cast`, в таком виде оно и переехало в русский жаргон - каст. Так вот VEX умеет неявно преобразовывать между
некоторыми из своих стандартных типов, что часто может вызывать недоразумения у неопытных программистов. Однако
компилятор VEX таки всегда выдаёт предупреждение при неявном преобразовании, что облегчает поиск проблем. Например,
`float a = {2, 3, 4};` - это корректное выражение. `vector {2, 3, 4}` будет неявно преобразован во `float`, и результат
присвоен в переменную `a`. ("каст" `vector` во `float` в VEX - это просто взятие первой компоненты `vector`, так что
значение в `a` будет `2`)

Все становится немного сложнее, когда выражения разных типов встречаются в арифметическом операторе.
Например,

```c
vector v3;
vector4 v4;
float a = v3 + v4;
```

Что произойдет тут?

Компилятор VEX выберет и нужные преобразования и добавит их в итоговую программу, это и называется неявным
преобразованием, но что преобразуется во что?

В данном случае `v3` будет преобразована к типу `vector4`, затем произойдет сложение двух `vector4`, затем результат
будет преобразован во `float` и присвоен в а почему именно `v3` преобразуется к типу `vector4`, а не `v4` преобразуется к
типу `vector`?

Это зашито в компилятор. При выборе преобразований VEX-компилятор, в отличии от C и подобных языков, учитывает и
операнды, и ожидаемый тип результата (так что об арифметических операторах можно думать как о вызовах функции типа
`type1 add(type2 a; type3 b)`, и смотреть далее про перегрузку функций.) это делает муторным, да и нужным ли вообще,
делать описание всех преобразований между всеми стандартными типами, вместо этого проще опираться на эмпирическое
правило, что типы преобразуются с наименьшей потерей. Преобразовать `vector` в `vector4` - никаких данных не потеряется,
а преобразовать `vector4` в `vector` - для этого придется отбросить одну значимую компоненту.

Строки (`string`) и массивы никак неявно и явно не преобразуются, для работы с ними существуют отдельные наборы функций.

Если компилятор решает добавить операцию преобразования типа, он выдаст предупреждение, отображаемое на ноде. Чтобы
избавиться от предупреждения компилятора, и для бОльшей наглядности кода - лучше переписать выражение `float a = {2, 3,
4};` выше как `float a = (float){2, 3, 4};` или `float a = float({2, 3, 4});` (это выражение приведено исключительно для
наглядного примера, глубокого смысла оно не несёт)

Выражение типа `(type)expression` - это классический каст выражения в тип в C-подобных языках. Такое преобразование
подразумевает некоторые реальные действия в ходе выполнения программы, т.е такое преобразование - это операция.
Выражение типа `type(expression)` - это выражение, синтаксически похожее на классический конструктор каст для типа, но
на самом деле в VEX это немножко другое, к этому мы вернемся чуть позже. Если не хотите читать про перегрузку функций и
т.д просто всегда используйте этот тип преобразования и забудьте про первый.



##### Перегрузка функций

Перед этим поговорим о перегрузке функций.
В VEX существует концепция перегрузки функций, как и во многих процедурных языках. Это позволяет нам иметь несколько
функций с одинаковым именем, но разными сигнатурами (сигнатурой функции называется её имя, набор типов её аргументов и
тип результата).

Например, функция `rand(...)` - это на самом деле набор функций с одинаковым именем и разными типами входных (и
выходных) аргументов). Ради субъективного удобства мы отдаём компилятору задачу разобраться, какую именно функцию мы
хотим вызвать. Таким образом мы можем писать `rand(42), rand(2.34), rand({1, 2, 3})`, тогда как без концепции перегрузки
нам бы пришлось иметь разные имена функций для разных типов аргументов, например, `rand_i(42), rand_f(2.34), rand_v({1,
2, 3})`.

Кроме того, в отличии от C/C++, VEX так же умеет перегружать функции по типу возвращаемого значения. Тот же `rand(2.34)`
может вернуть как значение типа `float`, так и типа `vector`, в зависимости от того, где в коде оно находится, и что
решит компилятор.

Учитывая, что компилятор умеет преобразовывать типы аргументов, и еще и подбирать одну из перегруженных функций,
подходящую по типу как аргументов, так и возвращаемого значения - можно представить, какая это замороченная задача с
неоднозначным решением...

И в общем случае так и есть - представьте простейший гипотетический пример:

```c
float foo(float a; vector b){...}
float foo(vector a; float b){...}
float a = foo(1.1, 2.2);
```

Компилятор будет думать, то ли вызвать первую функцию, и "кастовать" `2.2` в `vector`, то ли вызвать вторую функцию и
"кастовать" `1.1` в `vector`... и выдаст ошибку, говорящую `Ambiguous call`.

В отличии от C/C++, в которых перегрузки по возвращаемому значению нет, VEX компилятору приходится анализировать цепочки
функций в выражении целиком, выбирая подходящие комбинации. На самом деле комбинация из перегрузки функций по
возвращаемому значению и нечётко описанного неявного преобразования типов создают довольно сильно запутанные ситуации в
случаях чуть более сложных, чем тривиальные.

Так что я считаю бессмысленно описывать тут чёткую логику, так как она выходит длинной, запутанной, и даже не до конца
продуманной, и почти не требуемой на практике.

Важно помнить ряд свойств:
- `int - float`, `float - vector<N>`, `vector<N> - vector<M>`, `matrix - matrix3` преобразуются друг в друга
компилятором неявно, но двойных и более преобразования компилятор делать не будет (например, `vector4 -> float -> int`)
- в цепи перегруженных функций в аргументах друг друга, типа `int i = f1(f2(f3(f4(smth))))` - компилятор попытается
выбрать функции, точно удовлетворяющие всем элементам с известными типами (как в этом примере `i` и `smth`). Если таких
комбинаций более чем одна, то компилятор выдаст ошибку `Ambiguous call` если же такой комбинации не существует - судя по
тестам, поведение компилятора явно _не детерминировано_. На практике он возьмёт произвольный набор функций, если возможно
неявное преобразование из типа выходного значения одной функции в тип аргумента другой (например тип выходного значения
`f3` в тип аргумента `f2`). Но компилятор _**не** будет выбирать набор функций, в котором число преобразований будет
минимальным_, как это можно было разумно предположить.
- можно предположить, что VEX не задумывался как язык, элегантно разрешающий большие конструкции из перегруженных
функций с перемешанными типами, так что лучше всегда преобразовывать типы данных вручную, явным образом, в коде.


Вернёмся к операторам преобразования типа.

Как уже было сказано, оператор `(type)x` - это по сути вызов функции `type convert_to_type(<any> x)` , то есть `(type)x`
превращается в реальные инструкции, выполняющиеся во время выполнения программы.

Конструкция `type(x)` в свою очередь была введена для подсказки компилятору, какую из перегруженных по возвращаемому
значению функций выбрать в момент компиляции.

`int x = int(rand(1.23))` - здесь `int(...)` подсказывает компилятору на момент компиляции, какую функцию из набора
перегруженных `rand` функций выбрать, конкретно выбрать те, которые возвращают `int`, среди них уже разбираться, что
выбрать согласно входным аргументам, который тут `1.23` - `float`.

Еще раз, конструкция `int(some_function(...))` выше учитывается только на момент компиляции, и не создаёт никаких
дополнительных инструкций для выполнения в самой программе. `(int)` - это по сути вызов функции конвертации, и оно как
раз создаёт дополнительные инструкции для выполнения в самой программе.

Однако заметьте, что эти два преобразования не взаимозаменяемы, вполне легально записать `float(rand(1.23))` и совсем не
легально записать `(float)rand(1.23)`.

Почему?

Как вы уже поняли из описания выше, о второй записи можно думать как о вызове функции, типа
`convert_to_float(rand(0.23))` , и эта функция `convert_to_float` перегружена по входному аргументу, она умеет
конвертить во `float` и `float` и `int`, и `vector`, и т.д., так что компилятор натыкается на проблему множественных
точных соответствий типов выбираемых функций, и выдаёт ошибку. Кроме того, чтобы избавить пользователя от мыслей о
разных типах каста, VEX будет интерпретировать запись вида `type(x)` как `(type)x`, если `x` - какое-то выражение и не
вызов функции.

**Таким образом вы можете смело использовать только форму `type(...)`**, и оставлять компилятору раздумья о
том, надо ли выполнять явное преобразование, или просто выбрать подходящую функцию.


-------
#### Массивы

Массивы в VEX - это структуры, позволяющие хранить множество значений одного заранее определённого типа данных.

```c
float x[]; // объявляет переменную х, являющуюся массивом для типа данных float.
```

Как уже говорилось, все элементы массива имеют один и тот же заранее определённый тип, который в VEX может быть любым
из имеющихся типов данных, в том числе и структур, кроме другого массива.

Размером/длиной массива называется число элементов в нём. Длину массива можно изменять набором функций, типа `resize,
insert, append, remove, push, pop`, и т.д, для получения длины массива есть функция `len`.

Доступ к элементам массива возможен с помощью индексирования:

```c
// индексы начинаются с нуля, а не с единицы
x[1] = 2;
x[2] = x[1] + x[0];
```

Инициализировать массив можно с помощью литералов в фигурных скобках, так же как и вектор, только элементами будут
литералы типа данных массива.

```c
float x[] = {1, 2, 3, 4, 5};
vector y[] = {{1, 2, 3}, {2, 3.5, 4}};
matrix2 z[] = {{1, 2, 3, 4}, {2, 3, 4, 5}};
```

или с помощью функции `array`

```c
float a = 3, b = 4;
float x[] = array(a, b, 2);
```

Заметьте, что несмотря на такое объявление, для преобразования типов и задания массивов в объявлениях функций
используется запись `<type>[]`.
Например,

```c
int[](nearpoints(...));
string[] get_some_strings(string a, float[] foos);
// функции, возвращающие массив без указания ключевого слова function перед именем функции,
// по каким-то причинам внутри текста врангла определять нельзя, только во внешнем инклюд файле
```

Массивы в VEX поддерживают "слайсинг", очень похожий на "питоновский",

```c
int x[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
printf("%f\n", x[5:7]);   // напечатает {6, 7}
printf("%f\n", x[3::2]);  // напечатает {4, 6, 8, 10}
```

т.е. `<array_var>[start:end:step]` (не забывайте, что элемент с индексом `end` не включается) и да, `printf` отлично
печатает массивы (и вектора)

Для удобства можно использовать отрицательный индекс, чтобы индексировать массив с конца. Запись `arr[-3]` эквивалентна
записи `arr[len(arr) - 3]`.

```c
int arr[] = {1, 2, 3, 4, 5};
printf("%f == %f\n", arr[-2], arr[len(arr) - 2]); // выведет: 4 == 4
```

Однако заметьте, что "враппинга" индекса не происходит, а значит индексирование отрицательным значением, меньшим чем
минус длина массива, будет индексированием вне границ массива. Чтение оттуда вернёт значение по умолчанию типа данных
массива, запись туда не приведёт ни к чему (в отличии от записи вне границ массива с положительным индексом)
Отрицательный индекс также можно использовать и в "слайсинге".

Индексирование массива - очень быстрая операция, можно не стесняясь ей пользоваться. Изменение размера массива -
медленная операция, старайтесь оптимизировать свой код, чтобы как можно реже изменять размер массива.

VEX прощает ошибки в работе с массивами, что может привести к серьезным потерям производительности. Например, индексацию
за пределами массива,

```c
vector arr[] = {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}};
printf("%f\n", arr[24]);  // выдаст {0, 0, 0}, хотя элемента с индексом 24 в массиве нет
arr[5] = {-1, -3, -5};  // в этом месте VEX увеличит массив до размера в 6 элементов
printf(%f\n, arr);  // выдаст {{1, 2, 3}, {2, 3, 4}, {3, 4, 5}, {0, 0, 0}, {0, 0, 0}, {-1, -3, -5}}
```
т.е при индексации на чтении за пределами массива будет возвращён "дефолтный"/нулевой элемент для типа данных массива
при индексации на запись за пределами массива - массив будет расширен, чтобы включать требуемый индекс учитывая всё
вышесказанное, следующий код будет крайне неоптимален,

```c
int arr[];
for(int i = 0; i < 1000; ++i){
  arr[i] = i * 2;  // массив будет расширен неявно для каждого нового значения i
}
```

при этом исправить его очень просто, добавив единовременный "ресайз" массива до нужной длины:

```c
int arr[];
resize(arr, 1000);
for(int i = 0; i < 1000; ++i){
  arr[i] = i * 2;
}
```

Многомерных массивов в VEX не существуют.


-------
#### Словарь

Совсем недавно (относительно момента написания статьи), с версии `Houdini 18.5`, в VEX так же появился тип словарь
(`dict`), схожий по логике с словарём из Python. Для незнакомых с концепцией словарей, можете думать о нём в VEX как о
массиве, у которого индексы не целые числа, а строки, а элементы могут быть перемешанных типов. Индекс в таком
представлении называется ключом. т.е, словарь - это соответствие ключа некоторому значению.

Знакомым с типом `dict` в питоне поспешу огорчить:
- `dict` в VEX **НЕ** допускает динамической типизации
- `dict` в VEX дико медленный, представьте, что вы работаете не с словарём из Python, а со словарём из Python
сериализованным в строку `json`
- ключи могут быть только строками
- а в остальном неплохо

В документации есть отдельная статья, посвященная [словарю](https://www.sidefx.com/docs/houdini/vex/dicts.html).

Словари - не исключение для статической типизации - типа значения словаря для каждого используемого ключа в VEX должен
быть понятен компилятору на момент компиляции. Логика точно такая же, как и перегруженных по возвращаемому значению
функций чтения геометрии (`point`, `prim`, `primuv` и т.д). Так что можно думать о словаре, как о функции, возвращающей значение
некоторого типа по переданному ей строковому аргументу, так же как функция `point` возвращает значение некоторого
фиксированного, но неизвестного компилятору типа по имени атрибута.

```c
dict d = {};  // литерал {} означает пустой словарь
d["one"] = 1;
d["dog"] = "bark";
d["cat"] = {"m", "e", "o", "w"};
d["key0"] = d["one"];  // ошибка, компилятор не может однозначно определить тип d["key0"] и d["one"]
d["key0"] = int(d["one"]);
// как и в случае с функциями, конструкция type(...) подсказывает компилятору,
// какую из перегруженных функций чтения словаря использовать
```
