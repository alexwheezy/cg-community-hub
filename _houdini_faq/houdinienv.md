---
title: Как работает houdini.env
order: 100
---

Все строчки, начинающиеся с # являются комментариями и на работу файла не влияют.
В остальном файл состоит из объявлений переменных в синтаксисе, схожем с set из csh,
или объявлении переменных в bash.

Каждая строчка задает значение переменной, все строчки выполняются последовательно 
сверху вниз, так что заданные выше переменные уже могут быть использованы в последующих строках

синтаксис записи прост: `Переменная=Значение`  
При этом между переменной и знаком `=`, знаком `=` и значением может быть сколько угодно пробелов 
(в отличии от bash и csh), значение будет считаться начинающимся с первого непробельного символа

В самом же значении могут быть пробелы, и не обязательно их эскейпить или заключать 
в кавычки. т.е. потребность в кавычках в принципе отпадает, так как вся строка до 
конца воспринимается как значение.

Eсли в значении встречаются слова вида `$SOMETHING` - это команда интерпретатору подставить 
на место `$SOMETHING` значение переменной `SOMETHING` или пустоту, если такая переменная 
не задана. Это может быть или переменная заданная в одной из строк выше, или переменная 
среды системы. Заметьте, что все замены происходят **ДО** присвоения, так что в значении 
может встречаться и задаваемая переменная, которая будет замененая на текущее значение переменной.
т.е.
```shell
DOG =cat
DOG=  $DOG is not a dog
```
в итоге значение `DOG` будет `cat is not a dog`

Чтобы отделить название заменяемой переменной от остальных слов - можно поместить 
название переменной в фигурные скобки: `${VARNAME}`  
Таким образом значение `${DOG}GINS` для примера выше превратится в `cat is not a dogGINS`

Совет - всегда использовать фигурные скобки на всякий случай, чтобы случайно не упустить 
потенциальные проблемы типа `$DOG_CAT` - вы хотели подставить значение переменной `DOG`, 
но `_` считается текстовым символом, а значит интерпретатор видит это как замену 
переменной `DOG_CAT`. если же всегда использовать скобки - `${DOG}_CAT` - будет 
интерпретировано именно так, как вы ожидали

символ `&` в специализированных переменных среды гудини будут заменены на дефолтное 
значение **этой конкретной переменной** при запуске гудини.

обычно имеет смысл добавлять этот символ в конец переопределенных гудини переменных, 
задающих список каких-либо путей, чтобы не сломать дефолтный функционал гудини.

добавлять этот символ несколько раз не имеет смысла, классическая ошибка:

```shell
SOME_PATH1= c:\my\fancy\path1;&
SOME_PATH2= c:\my\fancy\path2;&
HOUDINI_PATH=$SOME_PATH1;$SOME_PATH2;&
```

тогда финальное значение `HOUDINI_PATH` будет `c:\my\fancy\path1;&;c:\my\fancy\path2;&;&`,
где каждый `&` будет заменен на набор стандартных путей.

Обычно проблем это может даже и не вызвать, но так как пути слева имеют приоритет 
перед путями справа - если в `c:\my\fancy\path2` есть что-то, что должно оверрайдить 
какой-то стандартный файл, тот `&` перед c:\my\fancy\path2 теперь будет иметь приоритет, 
и оверрайд не сработает.

примечание про кавычки:  
кавычки `""` в значении будут интерпретированы, но интерпретируются они совсем не как может быть 
привычно тем, кто работает с шеллом. Судя по ряду экспериментов - кавычки в начале и конце 
значения просто удаляются будто их и не было, еще перед анализом значения на пробелы в начале 
и конце. кавычки же внутри текста, даже окруженные пробелами - считаются обычными 
символами, и никакой обработки над ними не происходит

